cprod <- cumprod(1-Y)
cprod  <- c(1,cprod[1:M-1])
V <- Y*cprod
print(sum(V))
V <- V/sum(V)
oth <- order(tau)
lines(c(min(tau)-100,tau[oth],max(tau)+100),c(0,cumsum(V[oth]),1),type="s",col="green",lwd=3)
set.seed(76)
Y <- rbeta(M,1,a)
tau <- rnorm(M,0,1)
cprod <- cumprod(1-Y)
cprod  <- c(1,cprod[1:M-1])
V <- Y*cprod
print(sum(V))
V <- V/sum(V)
oth <- order(tau)
lines(c(min(tau)-100,tau[oth],max(tau)+100),c(0,cumsum(V[oth]),1),type="s",col="blue",lwd=3)
oth <- order(tau)
curve(pnorm(x,0,1),from=-4,to=4,col="magenta",lwd=2,xlab=" ",ylab="",cex.axis=1.5) #magenta denotes the d.f. associated to alpha_0
lines(c(min(tau)-100,tau[oth],max(tau)+100),c(0,cumsum(V[oth]),1),type="s",col="red",lwd=3)
title("Simulated trajectory of the DP distribution function")
set.seed(99)
Y <- rbeta(M,1,a)
tau <- rnorm(M,0,1)
cprod <- cumprod(1-Y)
cprod  <- c(1,cprod[1:M-1])
V <- Y*cprod
print(sum(V))
V <- V/sum(V)
oth <- order(tau)
lines(c(min(tau)-100,tau[oth],max(tau)+100),c(0,cumsum(V[oth]),1),type="s",col="green",lwd=3)
set.seed(76)
Y <- rbeta(M,1,a)
tau <- rnorm(M,0,1)
cprod <- cumprod(1-Y)
cprod  <- c(1,cprod[1:M-1])
V <- Y*cprod
print(sum(V))
V <- V/sum(V)
oth <- order(tau)
lines(c(min(tau)-100,tau[oth],max(tau)+100),c(0,cumsum(V[oth]),1),type="s",col="blue",lwd=3)
### SAMPLING MANY trajectories of the DP df: we add them to the same plot
gra=gray(1:100/100)
gra=rep(gra,10)
for(j in 1:200){
set.seed(j)
Y <- rbeta(M,1,a)
tau <- rnorm(M,0,1)
cprod <- cumprod(1-Y)
cprod  <- c(1,cprod[1:M-1])
V <- Y*cprod
print(sum(V))
V <- V/sum(V)
oth <- order(tau)
lines(c(min(tau)-100,tau[oth],max(tau)+100),c(0,cumsum(V[oth]),1),type="s",col=gra[j])
}
curve(pnorm(x,0,1),from=-4,to=4,col="magenta",lwd=2,add=T)
a=0.5
M <- 500 #truncation level  M=500
Y <- vector(length=M)
tau <-  vector(length=M)
V <- vector(length=M)
Y <- rbeta(M,1,a)
tau <- rnorm(M,0,1)
cprod <- cumprod(1-Y)
cprod  <- c(1,cprod[1:M-1])
V <- Y*cprod
print(sum(V))
V <- V/sum(V)
par(mfrow=c(1,3))
oth <- order(tau)
curve(pnorm(x,0,1),from=-4,to=4,col="magenta",lwd=2,xlab="",ylab="",cex.axis=1.5)
lines(c(min(tau)-100,tau[oth],max(tau)+100),c(0,cumsum(V[oth]),1),type="s",col="red",lwd=3)
title("Total mass a=0.5")
gra=gray(1:100/100)
gra=rep(gra,10)
for(j in 1:50){
set.seed(j)
Y <- rbeta(M,1,a)
tau <- rnorm(M,0,1)
cprod <- cumprod(1-Y)
cprod  <- c(1,cprod[1:M-1])
V <- Y*cprod
print(sum(V))
V <- V/sum(V)
oth <- order(tau)
lines(c(min(tau)-100,tau[oth],max(tau)+100),c(0,cumsum(V[oth]),1),type="s",col=gra[j])
}
curve(pnorm(x,0,1),from=-4,to=4,col="magenta",lwd=2,add=T)
##
a=5
M <- 500 # truncation level   M=500
Y <- vector(length=M)
tau <-  vector(length=M)
V <- vector(length=M)
Y <- rbeta(M,1,a) #simulation of the beta rvs
tau <- rnorm(M,0,1) # tau_i iid from alpha_0= N(0,1)
cprod <- cumprod(1-Y)
cprod  <- c(1,cprod[1:M-1])
V <- Y*cprod
print(sum(V))
V <- V/sum(V)
oth <- order(tau)
curve(pnorm(x,0,1),from=-4,to=4,col="magenta",lwd=2,xlab="",ylab="",cex.axis=1.5)
lines(c(min(tau)-100,tau[oth],max(tau)+100),c(0,cumsum(V[oth]),1),type="s",col="red",lwd=3)
title("Total mass a=5")
gra=gray(1:100/100)
gra=rep(gra,10)
for(j in 1:50){
set.seed(j)
Y <- rbeta(M,1,a)
tau <- rnorm(M,0,1)
cprod <- cumprod(1-Y)
cprod  <- c(1,cprod[1:M-1])
V <- Y*cprod
print(sum(V))
V <- V/sum(V)
oth <- order(tau)
lines(c(min(tau)-100,tau[oth],max(tau)+100),c(0,cumsum(V[oth]),1),type="s",col=gra[j])
}
curve(pnorm(x,0,1),from=-4,to=4,col="magenta",lwd=2,add=T)
##
a=50
M <- 500 #
Y <- vector(length=M)
tau <-  vector(length=M)
V <- vector(length=M)
Y <- rbeta(M,1,a)
tau <- rnorm(M,0,1)
cprod <- cumprod(1-Y)
cprod  <- c(1,cprod[1:M-1])
V <- Y*cprod
print(sum(V))
V <- V/sum(V)
oth <- order(tau)
curve(pnorm(x,0,1),from=-4,to=4,col="magenta",lwd=2,xlab="",ylab="",cex.axis=1.5)
lines(c(min(tau)-100,tau[oth],max(tau)+100),c(0,cumsum(V[oth]),1),type="s",col="red",lwd=3)
title("Total mass a=50")
gra=gray(1:100/100)
gra=rep(gra,10)
for(j in 1:50){
set.seed(j)
Y <- rbeta(M,1,a)
tau <- rnorm(M,0,1)
cprod <- cumprod(1-Y)
cprod  <- c(1,cprod[1:M-1])
V <- Y*cprod
print(sum(V))
V <- V/sum(V)
oth <- order(tau)
lines(c(min(tau)-100,tau[oth],max(tau)+100),c(0,cumsum(V[oth]),1),type="s",col=gra[j])
}
curve(pnorm(x,0,1),from=-4,to=4,col="magenta",lwd=2,add=T,xlab="",ylab="",cex.axis=1.5)
a=1
M <- 100
Y <- vector(length=M)
tau <-  vector(length=M)
V <- vector(length=M)
# Simulation
Y <- rbeta(M,1,a)
tau <- rnorm(M,0,1)
cprod <- cumprod(1-Y)
cprod  <- c(1,cprod[1:M-1])
V <- Y*cprod
print(sum(V))
V <- V/sum(V)
round(V,6)
n=10 ## sample size
theta<-vector(length=n)
index <-vector(length=n)
for(j in 1:n){
index[j] <- sample(1:M,size=1,prob=V) #sample one item
# without replacement
theta[j]=tau[index[j]]
}
index
theta
unique(theta)
a=1  #0.1, 1,  100
n=10 ## sample size ##n=2, 5, 10, 100, 697
theta<-vector(length=n) #simulated values: I rename it theta instead than Y
theta[1] <- rnorm(1) #first simulated value from alpha_0 = N(0,1)
?sample
for(j in 2:n){ ## from the second simulated value, we get
w0<- a/(j-1+a) ## a NEW observation from alpha_0 with probability w0
w1<-rep(1/(j-1+a),j-1) ## or an OLD observation, each of the old obs with prob w1
index <- sample(0:(j-1),size=1,prob=c(w0,w1))
# Sample the index from a discrete distribution with weights
#   contained in the vector prob, i.e. sample from the categorical distr.
if(index==0){
theta[j] <- rnorm(1) # NEW observation
}
else{
theta[j]=theta[index] # OLD observation
}
}
theta
unique(theta)
k <- length(unique(theta))
k
k <- vector(length=5000)
set.seed(19)
for(i in 1:5000){ ##Sampling from the generalized Polya urn repeatedly
##################################
##################################
theta[1] <- rnorm(1)
for(j in 2:n){
w0<-a/(j-1+a)
w1<-rep(1/(j-1+a),j-1)
index <- sample(0:(j-1),size=1,prob=c(w0,w1))
if(index==0){
theta[j] <- rnorm(1)
}
else{
theta[j]=theta[index]
}
}
###########################
###########################
k[i] <- length(unique(theta))
}
k
ymax=max(table(k)/5000)+0.01
plot(table(k)/5000,ylim=c(0,ymax),ylab="")
title("Prior probability of the number of clusters")
# Compare this MC distribution to the "exact" one - Antoniak 1974 (Ewens formula)
library(gsl) # library gsl to compute log of the Gamma function  lngamma
library(untb) # library containing logS1
a=1 ##### TOTAL MASS parameter
M <- 500 # truncation level   M=1000 o M=500
install.packages("gsl")
install.packages("untb")
Y <- vector(length=M)
tau <-  vector(length=M)
V <- vector(length=M)
a=1 ##### TOTAL MASS parameter
M <- 500 # truncation level   M=1000 o M=500
install.packages("gsl")
install.packages(c("rbiutils", "gmp", "sets", "mathjaxr", "Rdpack", "Brobdingnag", "partitions", "polynom"))
install.packages("untb")
Y <- vector(length=M)
tau <-  vector(length=M)
V <- vector(length=M)
install.packages("untb")
Y <- vector(length=M)
tau <-  vector(length=M)
V <- vector(length=M)
set.seed(13)  # let's fix the seed
Y <- rbeta(M,1,a) # Y_i's are beta(1,a)-distributed
tau <- rnorm(M,0,1) # simulated tau_i
cprod <- cumprod(1-Y)
cprod  <- c(1,cprod[1:M-1])
V <- Y*cprod   ## V_i = Y_i \prod_{j=1}^{i-1}(1-Y_j)
print(sum(V))  ## Compute the sum of all weights so far
V <- V/sum(V)  ## Rinormalization of the weights (needed because truncation of the infinite series)
curve(dnorm(x,0,1),from=-4,to=4,col="magenta",lwd=2,ylim=c(0,0.5),xlab=" ",ylab="",cex.axis=1.5) #mean parameter alpha_0 (in magenta)
abline(h=0,lty=2)
lines(tau,V,"h",lwd=3,col="red")
title("Weights and support points \nfor a simulated trajectory of a DP \n ")
sort(V,decreasing=T)[1:50]
oth <- order(tau)
curve(pnorm(x,0,1),from=-4,to=4,col="magenta",lwd=2,xlab=" ",ylab="",cex.axis=1.5) #magenta denotes the d.f. associated to alpha_0
lines(c(min(tau)-100,tau[oth],max(tau)+100),c(0,cumsum(V[oth]),1),type="s",col="red",lwd=3)
title("Simulated trajectory of the DP distribution function")
oth <- order(tau)
curve(pnorm(x,0,1),from=-4,to=4,col="magenta",lwd=2,xlab=" ",ylab="",cex.axis=1.5) #magenta denotes the d.f. associated to alpha_0
lines(c(min(tau)-100,tau[oth],max(tau)+100),c(0,cumsum(V[oth]),1),type="s",col="red",lwd=3)
title("Simulated trajectory of the DP distribution function")
set.seed(99)
Y <- rbeta(M,1,a)
tau <- rnorm(M,0,1)
cprod <- cumprod(1-Y)
cprod  <- c(1,cprod[1:M-1])
V <- Y*cprod
print(sum(V))
V <- V/sum(V)
oth <- order(tau)
lines(c(min(tau)-100,tau[oth],max(tau)+100),c(0,cumsum(V[oth]),1),type="s",col="green",lwd=3)
set.seed(76)
Y <- rbeta(M,1,a)
tau <- rnorm(M,0,1)
cprod <- cumprod(1-Y)
cprod  <- c(1,cprod[1:M-1])
V <- Y*cprod
print(sum(V))
V <- V/sum(V)
oth <- order(tau)
lines(c(min(tau)-100,tau[oth],max(tau)+100),c(0,cumsum(V[oth]),1),type="s",col="blue",lwd=3)
oth <- order(tau)
curve(pnorm(x,0,1),from=-4,to=4,col="magenta",lwd=2,xlab=" ",ylab="",cex.axis=1.5) #magenta denotes the d.f. associated to alpha_0
lines(c(min(tau)-100,tau[oth],max(tau)+100),c(0,cumsum(V[oth]),1),type="s",col="red",lwd=3)
title("Simulated trajectory of the DP distribution function")
set.seed(99)
Y <- rbeta(M,1,a)
tau <- rnorm(M,0,1)
cprod <- cumprod(1-Y)
cprod  <- c(1,cprod[1:M-1])
V <- Y*cprod
print(sum(V))
V <- V/sum(V)
oth <- order(tau)
lines(c(min(tau)-100,tau[oth],max(tau)+100),c(0,cumsum(V[oth]),1),type="s",col="green",lwd=3)
set.seed(76)
Y <- rbeta(M,1,a)
tau <- rnorm(M,0,1)
cprod <- cumprod(1-Y)
cprod  <- c(1,cprod[1:M-1])
V <- Y*cprod
print(sum(V))
V <- V/sum(V)
oth <- order(tau)
lines(c(min(tau)-100,tau[oth],max(tau)+100),c(0,cumsum(V[oth]),1),type="s",col="blue",lwd=3)
### SAMPLING MANY trajectories of the DP df: we add them to the same plot
gra=gray(1:100/100)
gra=rep(gra,10)
for(j in 1:200){
set.seed(j)
Y <- rbeta(M,1,a)
tau <- rnorm(M,0,1)
cprod <- cumprod(1-Y)
cprod  <- c(1,cprod[1:M-1])
V <- Y*cprod
print(sum(V))
V <- V/sum(V)
oth <- order(tau)
lines(c(min(tau)-100,tau[oth],max(tau)+100),c(0,cumsum(V[oth]),1),type="s",col=gra[j])
}
curve(pnorm(x,0,1),from=-4,to=4,col="magenta",lwd=2,add=T)
a=0.5
M <- 500 #truncation level  M=500
Y <- vector(length=M)
tau <-  vector(length=M)
V <- vector(length=M)
Y <- rbeta(M,1,a)
tau <- rnorm(M,0,1)
cprod <- cumprod(1-Y)
cprod  <- c(1,cprod[1:M-1])
V <- Y*cprod
print(sum(V))
V <- V/sum(V)
par(mfrow=c(1,3))
oth <- order(tau)
curve(pnorm(x,0,1),from=-4,to=4,col="magenta",lwd=2,xlab="",ylab="",cex.axis=1.5)
lines(c(min(tau)-100,tau[oth],max(tau)+100),c(0,cumsum(V[oth]),1),type="s",col="red",lwd=3)
title("Total mass a=0.5")
gra=gray(1:100/100)
gra=rep(gra,10)
for(j in 1:50){
set.seed(j)
Y <- rbeta(M,1,a)
tau <- rnorm(M,0,1)
cprod <- cumprod(1-Y)
cprod  <- c(1,cprod[1:M-1])
V <- Y*cprod
print(sum(V))
V <- V/sum(V)
oth <- order(tau)
lines(c(min(tau)-100,tau[oth],max(tau)+100),c(0,cumsum(V[oth]),1),type="s",col=gra[j])
}
curve(pnorm(x,0,1),from=-4,to=4,col="magenta",lwd=2,add=T)
##
a=5
M <- 500 # truncation level   M=500
Y <- vector(length=M)
tau <-  vector(length=M)
V <- vector(length=M)
Y <- rbeta(M,1,a) #simulation of the beta rvs
tau <- rnorm(M,0,1) # tau_i iid from alpha_0= N(0,1)
cprod <- cumprod(1-Y)
cprod  <- c(1,cprod[1:M-1])
V <- Y*cprod
print(sum(V))
V <- V/sum(V)
oth <- order(tau)
curve(pnorm(x,0,1),from=-4,to=4,col="magenta",lwd=2,xlab="",ylab="",cex.axis=1.5)
lines(c(min(tau)-100,tau[oth],max(tau)+100),c(0,cumsum(V[oth]),1),type="s",col="red",lwd=3)
title("Total mass a=5")
gra=gray(1:100/100)
gra=rep(gra,10)
for(j in 1:50){
set.seed(j)
Y <- rbeta(M,1,a)
tau <- rnorm(M,0,1)
cprod <- cumprod(1-Y)
cprod  <- c(1,cprod[1:M-1])
V <- Y*cprod
print(sum(V))
V <- V/sum(V)
oth <- order(tau)
lines(c(min(tau)-100,tau[oth],max(tau)+100),c(0,cumsum(V[oth]),1),type="s",col=gra[j])
}
curve(pnorm(x,0,1),from=-4,to=4,col="magenta",lwd=2,add=T)
##
a=50
M <- 500 #
Y <- vector(length=M)
tau <-  vector(length=M)
V <- vector(length=M)
Y <- rbeta(M,1,a)
tau <- rnorm(M,0,1)
cprod <- cumprod(1-Y)
cprod  <- c(1,cprod[1:M-1])
V <- Y*cprod
print(sum(V))
V <- V/sum(V)
oth <- order(tau)
curve(pnorm(x,0,1),from=-4,to=4,col="magenta",lwd=2,xlab="",ylab="",cex.axis=1.5)
lines(c(min(tau)-100,tau[oth],max(tau)+100),c(0,cumsum(V[oth]),1),type="s",col="red",lwd=3)
title("Total mass a=50")
gra=gray(1:100/100)
gra=rep(gra,10)
for(j in 1:50){
set.seed(j)
Y <- rbeta(M,1,a)
tau <- rnorm(M,0,1)
cprod <- cumprod(1-Y)
cprod  <- c(1,cprod[1:M-1])
V <- Y*cprod
print(sum(V))
V <- V/sum(V)
oth <- order(tau)
lines(c(min(tau)-100,tau[oth],max(tau)+100),c(0,cumsum(V[oth]),1),type="s",col=gra[j])
}
curve(pnorm(x,0,1),from=-4,to=4,col="magenta",lwd=2,add=T,xlab="",ylab="",cex.axis=1.5)
a=1
M <- 100
Y <- vector(length=M)
tau <-  vector(length=M)
V <- vector(length=M)
# Simulation
Y <- rbeta(M,1,a)
tau <- rnorm(M,0,1)
cprod <- cumprod(1-Y)
cprod  <- c(1,cprod[1:M-1])
V <- Y*cprod
print(sum(V))
V <- V/sum(V)
round(V,6)
n=10 ## sample size
theta<-vector(length=n)
index <-vector(length=n)
for(j in 1:n){
index[j] <- sample(1:M,size=1,prob=V) #sample one item
# without replacement
theta[j]=tau[index[j]]
}
index
theta
unique(theta)
a=1  #0.1, 1,  100
n=10 ## sample size ##n=2, 5, 10, 100, 697
theta<-vector(length=n) #simulated values: I rename it theta instead than Y
theta[1] <- rnorm(1) #first simulated value from alpha_0 = N(0,1)
?sample
for(j in 2:n){ ## from the second simulated value, we get
w0<- a/(j-1+a) ## a NEW observation from alpha_0 with probability w0
w1<-rep(1/(j-1+a),j-1) ## or an OLD observation, each of the old obs with prob w1
index <- sample(0:(j-1),size=1,prob=c(w0,w1))
# Sample the index from a discrete distribution with weights
#   contained in the vector prob, i.e. sample from the categorical distr.
if(index==0){
theta[j] <- rnorm(1) # NEW observation
}
else{
theta[j]=theta[index] # OLD observation
}
}
theta
unique(theta)
k <- length(unique(theta))
k
k <- vector(length=5000)
set.seed(19)
for(i in 1:5000){ ##Sampling from the generalized Polya urn repeatedly
##################################
##################################
theta[1] <- rnorm(1)
for(j in 2:n){
w0<-a/(j-1+a)
w1<-rep(1/(j-1+a),j-1)
index <- sample(0:(j-1),size=1,prob=c(w0,w1))
if(index==0){
theta[j] <- rnorm(1)
}
else{
theta[j]=theta[index]
}
}
###########################
###########################
k[i] <- length(unique(theta))
}
k
ymax=max(table(k)/5000)+0.01
plot(table(k)/5000,ylim=c(0,ymax),ylab="")
title("Prior probability of the number of clusters")
# Compare this MC distribution to the "exact" one - Antoniak 1974 (Ewens formula)
library(gsl) # library gsl to compute log of the Gamma function  lngamma
library(untb) # library containing logS1
#logS1[] e' una matrice che contiene il logaritmo dei numeri di Stirling di primo tipo
# di primo tipo sulla matrice [1:100]*[1:100]
## dato che n=100 la possiamo  utilizzare
pk <- vector(length=n) ## EXACT (analytic) probability                           #  density of K_n  in the log scale
cost.a <- lngamma(a)-lngamma(a+n)
for(l in 1:n){
pk[l] <- logS1[n,l]+l*log(a)+cost.a #logaritmo di pk
}
pk=exp(pk) #probabilities in teh original scale
points(1:n,pk,type="b",col="red",lty=2) # let's plot the  probability masses of the exact distribution of $K_n$
meanKn= a *sum(1/( a+seq(0,n-1))) # computed via its analytic expression
meanKn
sum(seq(1:n)*pk) # Monte Carlo approximation
